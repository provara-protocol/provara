{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Provara API Documentation","text":"<p>Welcome to the Provara Protocol API reference. This documentation covers the Python reference implementation \u2014 a complete, production-grade SDK for building tamper-evident, self-sovereign event logs.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Protocol Specification \u2014 Normative specification (RFC-style)</li> <li>Getting Started \u2014 Installation and basic usage</li> <li>GitHub Repository \u2014 Source code and issues</li> </ul>"},{"location":"#core-modules","title":"Core Modules","text":"<p>The reference implementation consists of 8 core cryptographic and operational modules:</p>"},{"location":"#cryptographic-foundation","title":"Cryptographic Foundation","text":"<ul> <li>canonical_json \u2014 RFC 8785 deterministic JSON serialization</li> <li>backpack_signing \u2014 Ed25519 signing and verification</li> <li>backpack_integrity \u2014 SHA-256 hashing, Merkle trees, path validation</li> </ul>"},{"location":"#event-processing","title":"Event Processing","text":"<ul> <li>reducer_v0 \u2014 Deterministic belief reducer (OBSERVATION \u2192 state)</li> <li>sync_v0 \u2014 Union merge, causal chain verification, fencing tokens</li> <li>manifest_generator \u2014 Manifest + Merkle root generation</li> </ul>"},{"location":"#vault-lifecycle","title":"Vault Lifecycle","text":"<ul> <li>bootstrap_v0 \u2014 Genesis vault creation</li> <li>rekey_backpack \u2014 Key rotation protocol</li> </ul>"},{"location":"#utilities-extensions","title":"Utilities &amp; Extensions","text":"<ul> <li>checkpoint_v0 \u2014 Signed state snapshots for fast replay</li> <li>perception_v0 \u2014 Sensor data hierarchy (T0\u2013T3)</li> <li>CLI \u2014 Command-line interface</li> </ul>"},{"location":"#integration-points","title":"Integration Points","text":"<ul> <li>MCP Server \u2014 Model Context Protocol for AI agents</li> <li>PSMC \u2014 Personal Sovereign Memory Container</li> </ul>"},{"location":"#one-external-dependency","title":"One External Dependency","text":"<pre><code>cryptography &gt;= 41.0\n</code></pre> <p>That's it. No frameworks, no ORM, no build complexity. Just cryptographic primitives and stdlib.</p>"},{"location":"#key-design-principles","title":"Key Design Principles","text":"<ol> <li>Determinism \u2014 Same events always produce the same state hash on any machine.</li> <li>Append-only \u2014 Events are never modified or deleted. New evidence supersedes old.</li> <li>Tamper-evident \u2014 Merkle trees, signatures, and causal chains detect any modification.</li> <li>Replayable \u2014 The complete event log is preserved. Auditors can verify conclusions.</li> <li>50-year readable \u2014 JSON, SHA-256, and Ed25519 are industry standards.</li> </ol>"},{"location":"#module-dependency-graph","title":"Module Dependency Graph","text":"<pre><code>bootstrap_v0 \u2500\u2500\u2192 backpack_signing \u2500\u2500\u2192 canonical_json\n     \u2502                  \u2502\n     \u25bc                  \u25bc\nreducer_v0      backpack_integrity\n     \u2502                  \u2502\n     \u25bc                  \u25bc\nsync_v0 \u25c4\u2500\u2500\u2500\u2500 manifest_generator\n     \u2502\n     \u25bc\nrekey_backpack \u2500\u2500\u2192 backpack_signing\n</code></pre> <p>All modules import from stdlib + <code>cryptography</code> only. No circular dependencies.</p>"},{"location":"#development","title":"Development","text":""},{"location":"#running-tests","title":"Running Tests","text":"<pre><code># All unit tests (125)\npython -m pytest tests/ -v\n\n# Compliance tests (17)\npython tests/backpack_compliance_v1.py tests/fixtures/reference_backpack -v\n\n# Full suite (232 tests)\nmake test\n</code></pre>"},{"location":"#type-checking","title":"Type Checking","text":"<pre><code># Already passing --strict\npython -m mypy --strict --ignore-missing-imports src/provara/\n</code></pre>"},{"location":"#license","title":"License","text":"<p>Apache 2.0. See LICENSE in the repository.</p>"},{"location":"#questions","title":"Questions?","text":"<ul> <li>Open an issue on GitHub</li> <li>Read the protocol specification</li> <li>Check the threat model</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>pip install provara-protocol\n</code></pre>"},{"location":"getting-started/#create-your-first-vault","title":"Create Your First Vault","text":"<pre><code>from provara.bootstrap_v0 import bootstrap\nfrom pathlib import Path\n\n# Create vault with dual-key authority\nvault_path = Path(\"My_Backpack\")\nkeys = bootstrap(vault_path, quorum=True, self_test=True)\n\nprint(f\"\u2713 Vault created at {vault_path}\")\nprint(f\"\u2713 Root Key: {keys['root_key_id']}\")\nprint(f\"\u2713 Quorum Key: {keys['quorum_key_id']}\")\n</code></pre>"},{"location":"getting-started/#add-your-first-event","title":"Add Your First Event","text":"<pre><code>from provara import Vault\nimport json\n\nvault = Vault(vault_path)\n\n# Record an observation\nevent = {\n    \"type\": \"OBSERVATION\",\n    \"subject\": \"family\",\n    \"predicate\": \"member\",\n    \"value\": \"Alice\",\n    \"confidence\": 0.95,\n}\n\nvault.append_event(event, keys[\"root_key_id\"], keys[\"root_private_key_b64\"])\n</code></pre>"},{"location":"getting-started/#verify-vault-integrity","title":"Verify Vault Integrity","text":"<pre><code>from provara.backpack_integrity import compute_merkle_root\nfrom pathlib import Path\nimport json\n\n# Re-generate and compare Merkle root\nfiles = [\n    vault_path / \"identity/genesis.json\",\n    vault_path / \"events/events.ndjson\",\n]\n\ncomputed_root = compute_merkle_root(files)\nstored_root = (vault_path / \"merkle_root.txt\").read_text().strip()\n\nif computed_root == stored_root:\n    print(\"\u2713 Vault integrity verified\")\nelse:\n    print(\"\u2717 Tampering detected!\")\n</code></pre>"},{"location":"getting-started/#sync-two-vaults","title":"Sync Two Vaults","text":"<pre><code>from provara.sync_v0 import sync\nfrom pathlib import Path\n\nvault1 = Path(\"Vault_Desktop\")\nvault2 = Path(\"Vault_Phone\")\nmerged = Path(\"Vault_Merged\")\n\nresult = sync(vault1, vault2, merged)\n\nprint(f\"Merged {result['new_events_in_merge']} new events\")\nprint(f\"State hash: {result['state_hash']}\")\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Read the protocol specification</li> <li>Check out the module reference</li> <li>Join the community</li> </ul>"},{"location":"integration/mcp/","title":"MCP Server","text":"<p>Module: <code>tools/mcp_server/server.py</code></p> <p>Model Context Protocol integration. Connect any AI agent (Claude, GPT, etc.) to a Provara vault for tamper-evident memory.</p>"},{"location":"integration/mcp/#quick-start","title":"Quick Start","text":""},{"location":"integration/mcp/#stdio-mode-claude-code-cursor","title":"Stdio Mode (Claude Code, Cursor)","text":"<p>Add to <code>.mcp.json</code>:</p> <pre><code>{\n  \"mcpServers\": {\n    \"provara\": {\n      \"command\": \"python\",\n      \"args\": [\"path/to/tools/mcp_server/server.py\", \"--transport\", \"stdio\"]\n    }\n  }\n}\n</code></pre>"},{"location":"integration/mcp/#http-mode-claudeai-openai","title":"HTTP Mode (Claude.ai, OpenAI)","text":"<pre><code>python tools/mcp_server/server.py --transport http --port 8765\n# Connect to: http://localhost:8765/sse\n</code></pre>"},{"location":"integration/mcp/#available-tools","title":"Available Tools","text":"Tool Description <code>append_event</code> Write a signed event to the vault <code>verify_chain</code> Verify causal chain + signatures <code>snapshot_state</code> Get current state hash <code>query_timeline</code> Filter events by type/time <code>list_conflicts</code> Show contested beliefs <code>generate_digest</code> Weekly markdown digest <code>export_markdown</code> Full vault history as markdown <code>checkpoint_vault</code> Create signed state snapshot"},{"location":"integration/mcp/#example-agent-with-memory","title":"Example: Agent with Memory","text":"<pre><code># AI agent using Provara vault as persistent memory\n\nfrom provara.cli import Vault\n\nvault = Vault(Path(\"Agent_Memory\"))\n\n# Agent observes something\nobservation = {\n    \"type\": \"OBSERVATION\",\n    \"subject\": \"conversation_2024_02_17\",\n    \"predicate\": \"user_prefers\",\n    \"value\": \"technical_explanations\",\n    \"confidence\": 0.85\n}\n\nvault.append_event(observation, key_id, private_key)\n\n# Next session: agent recalls\nstate = vault.get_state()\npreferences = state.canonical.get(\"conversation_2024_02_17:user_prefers\")\n# Returns: \"technical_explanations\" (with 0.85 confidence)\n</code></pre>"},{"location":"integration/mcp/#references","title":"References","text":"<ul> <li>MCP Specification</li> <li>Provara: AI Agent Integration</li> </ul>"},{"location":"integration/psmc/","title":"PSMC","text":"<p>Module: <code>tools/psmc/psmc.py</code></p> <p>Personal Sovereign Memory Container. High-level application layer for vault operations.</p>"},{"location":"integration/psmc/#overview","title":"Overview","text":"<p>PSMC wraps Provara core modules in a user-friendly interface for:</p> <ul> <li>Creating and managing personal vaults</li> <li>Recording life events, decisions, and observations</li> <li>Querying beliefs with confidence scores</li> <li>Syncing across devices</li> <li>Generating digests and reports</li> </ul>"},{"location":"integration/psmc/#quick-start","title":"Quick Start","text":"<pre><code>from provara.psmc import PSMC\nfrom pathlib import Path\n\n# Open or create vault\ncontainer = PSMC(Path(\"My_Memory\"))\n\n# Record observation\ncontainer.record_observation(\n    subject=\"health/sleep\",\n    predicate=\"hours\",\n    value=8,\n    confidence=0.95\n)\n\n# Query beliefs\nsleep_data = container.query(\"health/sleep\", \"hours\")\n# Returns: belief with 0.95 confidence\n\n# Generate weekly digest\ndigest = container.generate_digest(days=7)\nprint(digest)\n</code></pre>"},{"location":"integration/psmc/#commands","title":"Commands","text":"<ul> <li><code>record_observation</code> \u2014 Add an observation</li> <li><code>record_decision</code> \u2014 Log a decision</li> <li><code>query</code> \u2014 Query beliefs</li> <li><code>list_conflicts</code> \u2014 Show conflicting observations</li> <li><code>sync</code> \u2014 Merge with another vault</li> <li><code>export</code> \u2014 Export as markdown or JSON</li> </ul>"},{"location":"integration/psmc/#references","title":"References","text":"<ul> <li>Provara: PSMC Tutorial</li> </ul>"},{"location":"modules/backpack_integrity/","title":"backpack_integrity","text":"<p>Module: <code>src/provara/backpack_integrity.py</code></p> <p>SHA-256 hashing, Merkle tree computation, path validation, and file integrity verification.</p>"},{"location":"modules/backpack_integrity/#core-functions","title":"Core Functions","text":""},{"location":"modules/backpack_integrity/#hash_filepath-path-str","title":"<code>hash_file(path: Path) -&gt; str</code>","text":"<p>Compute SHA-256 hex digest of a file.</p> <pre><code>from provara.backpack_integrity import hash_file\nfrom pathlib import Path\n\nfile_hash = hash_file(Path(\"vault/events/events.ndjson\"))\n# Returns: \"abc123...\" (64-char hex)\n</code></pre>"},{"location":"modules/backpack_integrity/#compute_merkle_rootfiles-listpath-str","title":"<code>compute_merkle_root(files: List[Path]) -&gt; str</code>","text":"<p>Compute Merkle root over a sorted list of files. Deterministic \u2014 same files always produce same root.</p> <pre><code>from provara.backpack_integrity import compute_merkle_root\nfrom pathlib import Path\n\nfiles = [\n    Path(\"vault/identity/genesis.json\"),\n    Path(\"vault/identity/keys.json\"),\n    Path(\"vault/events/events.ndjson\"),\n]\n\nroot = compute_merkle_root(files)\n# Returns: \"def456...\" (64-char hex)\n</code></pre>"},{"location":"modules/backpack_integrity/#validate_path_safetypath-path-base-path-bool","title":"<code>validate_path_safety(path: Path, base: Path) -&gt; bool</code>","text":"<p>Prevent directory traversal attacks. Ensure path is within base directory.</p> <pre><code>from provara.backpack_integrity import validate_path_safety\nfrom pathlib import Path\n\nbase = Path(\"My_Backpack\")\nsafe_path = Path(\"My_Backpack/events/events.ndjson\")\nunsafe_path = Path(\"My_Backpack/../../etc/passwd\")\n\nassert validate_path_safety(safe_path, base)  # True\nassert not validate_path_safety(unsafe_path, base)  # False\n</code></pre>"},{"location":"modules/backpack_integrity/#security-properties","title":"Security Properties","text":"<ul> <li>Determinism: Same files \u2192 same Merkle root across languages</li> <li>Tamper-detection: Single bit flip \u2192 different root</li> <li>No phantom files: Merkle tree includes only files in inventory</li> </ul>"},{"location":"modules/backpack_integrity/#example-vault-integrity-check","title":"Example: Vault Integrity Check","text":"<pre><code>from provara.backpack_integrity import compute_merkle_root\nfrom pathlib import Path\n\nvault_path = Path(\"My_Backpack\")\n\n# Collect all tracked files\ntracked_files = [\n    vault_path / \"identity/genesis.json\",\n    vault_path / \"identity/keys.json\",\n    vault_path / \"events/events.ndjson\",\n    vault_path / \"policies/safety_policy.json\",\n]\n\n# Compute root\ncomputed_root = compute_merkle_root(tracked_files)\n\n# Compare with stored root\nstored_root = (vault_path / \"merkle_root.txt\").read_text().strip()\n\nif computed_root != stored_root:\n    print(\"TAMPER DETECTED!\")\nelse:\n    print(\"Vault integrity verified.\")\n</code></pre>"},{"location":"modules/backpack_integrity/#references","title":"References","text":"<ul> <li>FIPS 180-4: SHA-256</li> <li>Provara: Merkle Tree Specification</li> </ul>"},{"location":"modules/backpack_signing/","title":"backpack_signing","text":"<p>Module: <code>src/provara/backpack_signing.py</code></p> <p>Ed25519 cryptographic signing layer. Implements RFC 8032 signing and verification.</p>"},{"location":"modules/backpack_signing/#security-model","title":"Security Model","text":"<ul> <li>Private keys NEVER in the backpack \u2014 Lives in HSM, env var, or operator keyfile</li> <li>Public keys in identity/keys.json \u2014 Registry of trusted signers</li> <li>Detached signatures \u2014 Event carries <code>signature</code> field (Ed25519 over canonical JSON)</li> <li>Key authority \u2014 Signing key must be active (not revoked, not future)</li> </ul>"},{"location":"modules/backpack_signing/#core-functions","title":"Core Functions","text":""},{"location":"modules/backpack_signing/#generate_keypair-tuplebytes-bytes","title":"<code>generate_keypair() -&gt; Tuple[bytes, bytes]</code>","text":"<p>Generate Ed25519 private + public key (32 bytes each).</p> <pre><code>from provara.backpack_signing import generate_keypair\nimport base64\n\nprivate_key, public_key = generate_keypair()\n\n# Store private key securely (e.g., env var, file with 0600 perms)\n# Register public key in identity/keys.json\n</code></pre>"},{"location":"modules/backpack_signing/#sign_eventevent-dictstr-any-private_key_b64-str-str","title":"<code>sign_event(event: Dict[str, Any], private_key_b64: str) -&gt; str</code>","text":"<p>Sign an event with Ed25519. Returns base64-encoded signature.</p> <pre><code>from provara.backpack_signing import sign_event\nimport base64\n\nevent = {\n    \"event_id\": \"evt_001\",\n    \"actor\": \"bp1_alice...\",\n    \"type\": \"OBSERVATION\",\n    \"subject\": \"x\",\n    \"predicate\": \"p\",\n    \"value\": 1,\n}\n\n# private_key_b64 is base64-encoded 32-byte Ed25519 private key\nprivate_key_b64 = \"...\"  # from secure storage\n\nsignature_b64 = sign_event(event, private_key_b64)\n\n# Add to event\nevent[\"signature\"] = signature_b64\n</code></pre>"},{"location":"modules/backpack_signing/#verify_eventevent-dictstr-any-public_key_b64-str-bool","title":"<code>verify_event(event: Dict[str, Any], public_key_b64: str) -&gt; bool</code>","text":"<p>Verify an event signature with Ed25519. Returns True if valid.</p> <pre><code>from provara.backpack_signing import verify_event\n\nis_valid = verify_event(event, public_key_b64)\n\nif not is_valid:\n    raise ValueError(f\"Signature invalid for event {event['event_id']}\")\n</code></pre>"},{"location":"modules/backpack_signing/#sign_manifestmerkle_root-str-manifest_header-dictstr-any-private_key_b64-str-str","title":"<code>sign_manifest(merkle_root: str, manifest_header: Dict[str, Any], private_key_b64: str) -&gt; str</code>","text":"<p>Sign manifest + Merkle root. Used in vault sealing.</p> <pre><code>from provara.backpack_signing import sign_manifest\n\nmanifest_header = {\n    \"merkle_root\": \"abc123...\",\n    \"version\": \"1.0\",\n    \"timestamp\": \"2024-02-17T16:00:00Z\"\n}\n\nmanifest_sig = sign_manifest(\"abc123...\", manifest_header, private_key_b64)\n</code></pre>"},{"location":"modules/backpack_signing/#verify_manifestmerkle_root-str-manifest_header-dictstr-any-manifest_sig-str-public_key_b64-str-bool","title":"<code>verify_manifest(merkle_root: str, manifest_header: Dict[str, Any], manifest_sig: str, public_key_b64: str) -&gt; bool</code>","text":"<p>Verify manifest signature.</p> <pre><code>from provara.backpack_signing import verify_manifest\n\nis_valid = verify_manifest(\n    merkle_root,\n    manifest_header,\n    manifest_sig,\n    public_key_b64\n)\n</code></pre>"},{"location":"modules/backpack_signing/#key-id-format","title":"Key ID Format","text":"<p>Key IDs follow the Backpack v1 format:</p> <pre><code>bp1_&lt;16-char-hex&gt;\n\nWhere &lt;16-char-hex&gt; = SHA-256(public_key_bytes)[:16]\n</code></pre> <p>Example: <code>bp1_a1b2c3d4e5f6g7h8</code></p>"},{"location":"modules/backpack_signing/#example-full-signing-workflow","title":"Example: Full Signing Workflow","text":"<pre><code>from provara.backpack_signing import (\n    generate_keypair,\n    sign_event,\n    verify_event,\n)\nimport base64\nfrom provara.canonical_json import canonical_hash\n\n# 1. Generate keys\nprivate_key_bytes, public_key_bytes = generate_keypair()\nprivate_key_b64 = base64.b64encode(private_key_bytes).decode()\npublic_key_b64 = base64.b64encode(public_key_bytes).decode()\n\n# 2. Create event\nevent = {\n    \"event_id\": \"evt_001\",\n    \"actor\": \"bp1_alice...\",\n    \"type\": \"OBSERVATION\",\n    \"subject\": \"x\",\n    \"predicate\": \"p\",\n    \"value\": \"hello\",\n    \"timestamp_utc\": \"2024-02-17T16:00:00Z\",\n    \"prev_event_hash\": None,\n}\n\n# 3. Sign\nsignature = sign_event(event, private_key_b64)\nevent[\"signature\"] = signature\n\n# 4. Verify\nis_valid = verify_event(event, public_key_b64)\nassert is_valid, \"Signature invalid!\"\n\n# 5. Hash for chain\nevent_hash = canonical_hash(event)\n\n# 6. Create next event\nnext_event = {\n    **event,\n    \"event_id\": \"evt_002\",\n    \"prev_event_hash\": event_hash,\n    \"value\": \"world\",\n}\n\n# Sign and verify next event\nnext_signature = sign_event(next_event, private_key_b64)\nnext_event[\"signature\"] = next_signature\n\nassert verify_event(next_event, public_key_b64), \"Next event invalid!\"\n</code></pre>"},{"location":"modules/backpack_signing/#key-rotation","title":"Key Rotation","text":"<p>See <code>rekey_backpack.py</code> for the key rotation protocol. The signing layer is the foundation; rotation is an event-layer operation.</p>"},{"location":"modules/backpack_signing/#performance","title":"Performance","text":"<ul> <li>Key generation: ~5ms (one-time)</li> <li>Signing: ~0.5ms per event</li> <li>Verification: ~0.5ms per event</li> </ul> <p>For 1000 events: ~500ms total (signature validation in parallel).</p>"},{"location":"modules/backpack_signing/#security-considerations","title":"Security Considerations","text":"<ol> <li>Private key protection \u2014 Use env vars, HSM, or encrypted files. Never commit.</li> <li>Clock skew \u2014 Timestamps are informational, not validation. Causal order verified by <code>prev_hash</code>.</li> <li>Replay attacks \u2014 Prevented by causal chain. Same event signed twice has same signature (deterministic).</li> </ol>"},{"location":"modules/backpack_signing/#references","title":"References","text":"<ul> <li>RFC 8032: Edwards-Curve Digital Signature Algorithm (EdDSA)</li> <li>Provara Protocol: Signing &amp; Key Management</li> </ul>"},{"location":"modules/bootstrap_v0/","title":"bootstrap_v0","text":"<p>Module: <code>src/provara/bootstrap_v0.py</code></p> <p>Creates a fully compliant, cryptographically-signed vault from nothing.</p>"},{"location":"modules/bootstrap_v0/#what-it-does","title":"What It Does","text":"<ol> <li>Generates Ed25519 keypairs (root + optional quorum)</li> <li>Creates genesis event (vault birth certificate)</li> <li>Builds seed policies (safety, retention, sync governance)</li> <li>Generates manifest + Merkle root</li> <li>Verifies output passes all 17 compliance tests</li> </ol>"},{"location":"modules/bootstrap_v0/#core-functions","title":"Core Functions","text":""},{"location":"modules/bootstrap_v0/#bootstrapvault_path-path-quorum-bool-false-self_test-bool-false-dictstr-str","title":"<code>bootstrap(vault_path: Path, quorum: bool = False, self_test: bool = False) -&gt; Dict[str, str]</code>","text":"<p>Create a new vault at the specified path.</p> <pre><code>from provara.bootstrap_v0 import bootstrap\nfrom pathlib import Path\n\nvault_path = Path(\"My_Backpack\")\n\nkeys = bootstrap(vault_path, quorum=True, self_test=True)\n\n# keys = {\n#     \"root_key_id\": \"bp1_...\",\n#     \"root_private_key_b64\": \"...\",\n#     \"quorum_key_id\": \"bp1_...\",\n#     \"quorum_private_key_b64\": \"...\",\n# }\n</code></pre>"},{"location":"modules/bootstrap_v0/#parameters","title":"Parameters","text":"<ul> <li>vault_path: Directory to create vault in</li> <li>quorum: If True, generate separate recovery key (recommended)</li> <li>self_test: If True, run 17 compliance tests immediately</li> </ul>"},{"location":"modules/bootstrap_v0/#output-structure","title":"Output Structure","text":"<pre><code>My_Backpack/\n\u251c\u2500\u2500 identity/\n\u2502   \u251c\u2500\u2500 genesis.json              # Birth certificate\n\u2502   \u2514\u2500\u2500 keys.json                 # Public key registry\n\u251c\u2500\u2500 events/\n\u2502   \u2514\u2500\u2500 events.ndjson             # Event log (starts with GENESIS)\n\u251c\u2500\u2500 policies/\n\u2502   \u251c\u2500\u2500 safety_policy.json        # L0-L3 action tiers\n\u2502   \u251c\u2500\u2500 retention_policy.json     # Data permanence rules\n\u2502   \u2514\u2500\u2500 sync_contract.json        # Governance structure\n\u251c\u2500\u2500 state/                        # Regeneratable from events\n\u251c\u2500\u2500 manifest.json                 # File inventory\n\u251c\u2500\u2500 manifest.sig                  # Manifest signature\n\u2514\u2500\u2500 merkle_root.txt              # Integrity anchor\n</code></pre>"},{"location":"modules/bootstrap_v0/#genesis-event","title":"Genesis Event","text":"<pre><code>{\n    \"event_id\": \"evt_000_genesis\",\n    \"actor\": \"bp1_root...\",\n    \"type\": \"GENESIS\",\n    \"timestamp_utc\": \"2024-02-17T16:00:00Z\",\n    \"prev_event_hash\": null,\n    \"payload\": {\n        \"creator\": \"Provara Bootstrap v1.0\",\n        \"vault_version\": \"1.0\",\n        \"root_key_id\": \"bp1_root...\",\n        \"quorum_key_id\": \"bp1_quorum...\" // if --quorum\n    },\n    \"signature\": \"...\"\n}\n</code></pre>"},{"location":"modules/bootstrap_v0/#example-create-family-vault","title":"Example: Create Family Vault","text":"<pre><code>from provara.bootstrap_v0 import bootstrap\nfrom pathlib import Path\nimport json\n\nvault_path = Path(\"Family_Records\")\n\n# 1. Bootstrap vault with dual-key authority\nkeys = bootstrap(vault_path, quorum=True, self_test=True)\n\nprint(\"\u2713 Vault created\")\nprint(f\"\u2713 Root Key: {keys['root_key_id']}\")\nprint(f\"\u2713 Quorum Key: {keys['quorum_key_id']}\")\n\n# 2. Save private keys securely (separate locations)\n# In production: use HSM, KMS, or encrypted env vars\nkeys_file = Path(\"private_keys.json\")\nkeys_file.write_text(json.dumps(keys, indent=2))\nkeys_file.chmod(0o600)  # Read-only by owner\n\nprint(f\"\u2713 Private keys saved to {keys_file}\")\n\n# 3. Verify vault integrity\nfrom provara.backpack_integrity import compute_merkle_root\n\nfiles = [\n    vault_path / \"identity/genesis.json\",\n    vault_path / \"events/events.ndjson\",\n]\n\nroot = compute_merkle_root(files)\nstored_root = (vault_path / \"merkle_root.txt\").read_text().strip()\n\nassert root == stored_root, \"Merkle root mismatch!\"\nprint(\"\u2713 Vault integrity verified\")\n</code></pre>"},{"location":"modules/bootstrap_v0/#key-management","title":"Key Management","text":"<p>After bootstrap:</p> <ol> <li>Root key: Primary signing authority. Store in HSM or encrypted file.</li> <li>Quorum key: Recovery key. Store in physically separate location.</li> <li>Backup: Copy entire vault to USB/cloud regularly.</li> </ol> <p>NEVER commit private keys to Git.</p>"},{"location":"modules/bootstrap_v0/#compliance-tests","title":"Compliance Tests","text":"<p>Bootstrap runs 17 compliance tests:</p> <ul> <li>Directory structure (2 tests)</li> <li>Identity schema (2 tests)</li> <li>Event schema + causal chain (3 tests)</li> <li>Manifest + Merkle tree (5 tests)</li> <li>Safety policy (2 tests)</li> <li>Sync contract (1 test)</li> </ul> <p>All must pass for the vault to be usable.</p>"},{"location":"modules/bootstrap_v0/#references","title":"References","text":"<ul> <li>Provara: Bootstrap Specification</li> <li>Key Management Guide</li> </ul>"},{"location":"modules/canonical_json/","title":"canonical_json","text":"<p>Module: <code>src/provara/canonical_json.py</code></p> <p>Deterministic JSON canonicalization for content-addressed hashing. Implements RFC 8785 (JCS) canonical form.</p>"},{"location":"modules/canonical_json/#overview","title":"Overview","text":"<p>All cryptographic operations (hashing, signing, chain verification) operate on canonical JSON bytes. This ensures:</p> <ul> <li>Determinism: Same logical object always produces identical bytes</li> <li>Portability: Cross-language implementations produce identical hashes</li> <li>Auditability: Humans can verify hashes by hand if needed</li> </ul>"},{"location":"modules/canonical_json/#canonical-form-rules","title":"Canonical Form Rules","text":"<ol> <li>UTF-8 encoding \u2014 All strings encoded as UTF-8</li> <li>Sorted keys \u2014 Object keys ordered lexicographically by Unicode codepoint</li> <li>No whitespace \u2014 Compact separators (<code>\",\"</code> and <code>\":\"</code>)</li> <li>No NaN/Infinity \u2014 Raises <code>ValueError</code> if encountered</li> <li>Finite numbers \u2014 Python <code>json</code> module defaults (cross-language note: prefer integer encoding or string-wrapped decimals for fractional values)</li> </ol>"},{"location":"modules/canonical_json/#core-functions","title":"Core Functions","text":""},{"location":"modules/canonical_json/#canonical_dumpsobj-any-str","title":"<code>canonical_dumps(obj: Any) -&gt; str</code>","text":"<p>Return canonical JSON string with sorted keys and no whitespace.</p> <pre><code>from provara.canonical_json import canonical_dumps\n\nobj = {\"name\": \"Alice\", \"age\": 30}\ncanonical_str = canonical_dumps(obj)\n# Returns: '{\"age\":30,\"name\":\"Alice\"}'\n</code></pre>"},{"location":"modules/canonical_json/#canonical_bytesobj-any-bytes","title":"<code>canonical_bytes(obj: Any) -&gt; bytes</code>","text":"<p>Return canonical JSON as UTF-8 encoded bytes.</p> <pre><code>from provara.canonical_json import canonical_bytes\n\nobj = {\"event_id\": \"evt_123\", \"timestamp\": \"2024-01-01T00:00:00Z\"}\ncanonical_bytes(obj)\n# Returns: b'{\"event_id\":\"evt_123\",\"timestamp\":\"2024-01-01T00:00:00Z\"}'\n</code></pre>"},{"location":"modules/canonical_json/#sha256_hexdata-bytes-str","title":"<code>sha256_hex(data: bytes) -&gt; str</code>","text":"<p>Return lowercase hex SHA-256 digest of bytes.</p> <pre><code>from provara.canonical_json import sha256_hex\n\ndata = b\"some event data\"\ndigest = sha256_hex(data)\n# Returns: \"3f4a...\" (64-char hex string)\n</code></pre>"},{"location":"modules/canonical_json/#canonical_hashobj-any-str","title":"<code>canonical_hash(obj: Any) -&gt; str</code>","text":"<p>Return SHA-256 hex digest of canonical JSON bytes. This is the primary function for event hashing.</p> <pre><code>from provara.canonical_json import canonical_hash\n\nevent = {\n    \"event_id\": \"evt_123\",\n    \"actor\": \"alice\",\n    \"timestamp\": \"2024-01-01T00:00:00Z\"\n}\n\nevent_hash = canonical_hash(event)\n# Same event always produces same hash\n</code></pre>"},{"location":"modules/canonical_json/#security-notes","title":"Security Notes","text":"<ul> <li>Canonical form is deterministic but not cryptographic proof. It ensures reproducibility across implementations.</li> <li>Use <code>backpack_signing</code> for Ed25519 signatures over canonical bytes.</li> <li>Use <code>backpack_integrity</code> for Merkle tree hashing.</li> </ul>"},{"location":"modules/canonical_json/#cross-language-compatibility","title":"Cross-Language Compatibility","text":"<p>Before shipping a Provara implementation in a new language:</p> <ol> <li>Run the determinism test fixture: <code>test_vectors/vectors.json</code></li> <li>Verify that canonical JSON for each test vector produces the expected hash</li> <li>If hashes diverge, reconcile JSON serialization order and numeric precision</li> </ol>"},{"location":"modules/canonical_json/#example-event-hashing","title":"Example: Event Hashing","text":"<pre><code>from provara.canonical_json import canonical_hash\n\nevent = {\n    \"event_id\": \"evt_001\",\n    \"actor\": \"bp1_alice...\",\n    \"timestamp\": \"2024-02-17T16:00:00Z\",\n    \"prev_event_hash\": None,\n    \"type\": \"OBSERVATION\",\n    \"payload\": {\"subject\": \"family_tree\", \"predicate\": \"child_of\", \"value\": \"John\"},\n    \"confidence\": 0.95,\n}\n\n# Chain forward reference\nevent_hash = canonical_hash(event)\nnext_event = {\n    **event,\n    \"event_id\": \"evt_002\",\n    \"prev_event_hash\": event_hash,\n}\n\nnext_hash = canonical_hash(next_event)\n</code></pre>"},{"location":"modules/canonical_json/#performance","title":"Performance","text":"<p>Canonical JSON serialization is O(n) where n is object size. For typical events (&lt; 10 KB), serialization + hashing takes &lt; 1ms.</p>"},{"location":"modules/canonical_json/#references","title":"References","text":"<ul> <li>RFC 8785: JSON Canonicalization Scheme</li> <li>Provara Protocol Spec: Canonical JSON</li> </ul>"},{"location":"modules/checkpoint_v0/","title":"checkpoint_v0","text":"<p>Module: <code>src/provara/checkpoint_v0.py</code></p> <p>Signed state snapshots for fast replay. Enables O(1) vault state access without full event log scan.</p>"},{"location":"modules/checkpoint_v0/#quick-start","title":"Quick Start","text":"<pre><code>from provara.checkpoint_v0 import create_checkpoint, verify_checkpoint\nfrom pathlib import Path\n\nvault = Path(\"My_Backpack\")\n\n# Create checkpoint\ncheckpoint_path = vault / \"state\" / \"checkpoint_2024-02-17.json\"\ncreate_checkpoint(vault, checkpoint_path, private_key_b64)\n\n# Later: verify checkpoint\nis_valid = verify_checkpoint(checkpoint_path, public_key_b64)\n</code></pre>"},{"location":"modules/checkpoint_v0/#references","title":"References","text":"<ul> <li>Provara: Checkpoint Specification</li> </ul>"},{"location":"modules/cli/","title":"CLI","text":"<p>Module: <code>src/provara/cli.py</code></p> <p>Command-line interface for vault operations.</p>"},{"location":"modules/cli/#commands","title":"Commands","text":""},{"location":"modules/cli/#provara-init-path","title":"<code>provara init &lt;path&gt;</code>","text":"<p>Create a new vault.</p> <pre><code>provara init My_Backpack\n</code></pre>"},{"location":"modules/cli/#provara-verify-vault","title":"<code>provara verify &lt;vault&gt;</code>","text":"<p>Verify vault integrity (17 compliance tests).</p> <pre><code>provara verify My_Backpack\n</code></pre>"},{"location":"modules/cli/#provara-append-vault-eventjson","title":"<code>provara append &lt;vault&gt; &lt;event.json&gt;</code>","text":"<p>Add an event to the vault.</p> <pre><code>provara append My_Backpack event.json\n</code></pre>"},{"location":"modules/cli/#provara-sync-vault_a-vault_b-output","title":"<code>provara sync &lt;vault_a&gt; &lt;vault_b&gt; &lt;output&gt;</code>","text":"<p>Merge two vaults.</p> <pre><code>provara sync Desktop_Vault Phone_Vault Merged_Vault\n</code></pre>"},{"location":"modules/cli/#provara-export-vault-format-markdown","title":"<code>provara export &lt;vault&gt; --format markdown</code>","text":"<p>Export vault as markdown.</p> <pre><code>provara export My_Backpack --format markdown &gt; vault.md\n</code></pre>"},{"location":"modules/cli/#references","title":"References","text":"<ul> <li>Provara: CLI Usage</li> </ul>"},{"location":"modules/manifest_generator/","title":"manifest_generator","text":"<p>Module: <code>src/provara/manifest_generator.py</code></p> <p>Generates <code>manifest.json</code> and <code>merkle_root.txt</code> for a backpack directory. Provides signed file inventory + integrity anchor.</p>"},{"location":"modules/manifest_generator/#core-functions","title":"Core Functions","text":""},{"location":"modules/manifest_generator/#generate_manifestvault_path-path-dictstr-any","title":"<code>generate_manifest(vault_path: Path) -&gt; Dict[str, Any]</code>","text":"<p>Generate manifest (file inventory + SHA-256 hashes) for a vault.</p> <pre><code>from provara.manifest_generator import generate_manifest\nfrom pathlib import Path\n\nvault = Path(\"My_Backpack\")\nmanifest = generate_manifest(vault)\n\n# manifest[\"files\"] \u2192 {\"path\": \"hash\", ...}\n# manifest[\"merkle_root\"] \u2192 hex string\n# manifest[\"timestamp\"] \u2192 ISO 8601\n</code></pre>"},{"location":"modules/manifest_generator/#write_manifestvault_path-path-manifest-dictstr-any-manifest_sig-str","title":"<code>write_manifest(vault_path: Path, manifest: Dict[str, Any], manifest_sig: str)</code>","text":"<p>Write manifest.json and merkle_root.txt to vault.</p> <pre><code>from provara.manifest_generator import write_manifest\n\nwrite_manifest(vault, manifest, signature)\n# Creates: vault/manifest.json, vault/manifest.sig, vault/merkle_root.txt\n</code></pre>"},{"location":"modules/manifest_generator/#example-sealing-a-vault","title":"Example: Sealing a Vault","text":"<pre><code>from provara.manifest_generator import generate_manifest, write_manifest\nfrom provara.backpack_signing import sign_manifest\nfrom pathlib import Path\nimport base64\n\nvault = Path(\"My_Backpack\")\n\n# 1. Generate manifest\nmanifest = generate_manifest(vault)\n\n# 2. Sign manifest\nmanifest_header = {\n    \"version\": \"1.0\",\n    \"timestamp\": manifest[\"timestamp\"],\n}\n\nprivate_key_b64 = \"...\"  # from secure storage\n\nsignature = sign_manifest(\n    manifest[\"merkle_root\"],\n    manifest_header,\n    private_key_b64\n)\n\n# 3. Write to vault\nwrite_manifest(vault, manifest, signature)\n</code></pre>"},{"location":"modules/manifest_generator/#integrity-verification","title":"Integrity Verification","text":"<pre><code>from provara.manifest_generator import generate_manifest\nfrom pathlib import Path\nimport json\n\nvault = Path(\"My_Backpack\")\n\n# Re-generate manifest from current vault state\ncurrent_manifest = generate_manifest(vault)\n\n# Read stored manifest\nstored_manifest = json.loads((vault / \"manifest.json\").read_text())\n\n# Compare Merkle roots\nif current_manifest[\"merkle_root\"] != stored_manifest[\"merkle_root\"]:\n    print(\"TAMPERING DETECTED!\")\nelse:\n    print(\"Vault intact.\")\n</code></pre>"},{"location":"modules/manifest_generator/#references","title":"References","text":"<ul> <li>Provara: Manifest Specification</li> </ul>"},{"location":"modules/perception_v0/","title":"perception_v0","text":"<p>Module: <code>src/provara/perception_v0.py</code></p> <p>Sensor data hierarchy. Organizes observations into trust tiers (T0\u2013T3) for structured sensor integration.</p>"},{"location":"modules/perception_v0/#perception-tiers","title":"Perception Tiers","text":"Tier Trust Latency Example T0 System Instant Internal state, heartbeat T1 Trusted &lt; 1s Validated sensor input T2 Uncertain &lt; 60s Network data, crowdsourced T3 Untrusted Any External claims, user input"},{"location":"modules/perception_v0/#example","title":"Example","text":"<pre><code>from provara.perception_v0 import emit_perception_event\n\n# T1: Trusted sensor (verified thermometer)\nevent = emit_perception_event(\n    tier=\"T1\",\n    sensor_id=\"temp_sensor_01\",\n    value=22.5,\n    unit=\"celsius\"\n)\n\n# T3: Untrusted user input (social media claim)\nevent = emit_perception_event(\n    tier=\"T3\",\n    source=\"twitter.com\",\n    claim=\"Alice is in Paris\",\n    confidence=0.3\n)\n</code></pre>"},{"location":"modules/perception_v0/#references","title":"References","text":"<ul> <li>Provara: Perception Ontology</li> </ul>"},{"location":"modules/reducer_v0/","title":"reducer_v0","text":"<p>Module: <code>src/provara/reducer_v0.py</code></p> <p>Deterministic belief reducer. Processes events to derive beliefs with byte-identical state hashes across all machines.</p>"},{"location":"modules/reducer_v0/#golden-rule","title":"Golden Rule","text":"<p>Truth is not merged. Evidence is merged. Truth is recomputed.</p> <p>The reducer is a pure function: <code>f(events) -&gt; state</code>. Given identical events, it always produces identical output. No heuristics, no guesses, no merge conflicts at the belief layer.</p>"},{"location":"modules/reducer_v0/#core-invariants","title":"Core Invariants","text":"<ol> <li>Events are immutable \u2014 Corrections are new events, not overwrites</li> <li>Determinism \u2014 Same events in same order \u2192 byte-identical state hash</li> <li>Provenance required \u2014 Every claim includes actor, timestamp, confidence</li> <li>Reducer doesn't verify \u2014 Signature/chain verification is sync layer's job</li> </ol>"},{"location":"modules/reducer_v0/#four-namespace-model","title":"Four-Namespace Model","text":"<p>Beliefs are organized by epistemic status:</p> Namespace Meaning Promotion <code>canonical/</code> Institutionally attested truth Requires ATTESTATION event <code>local/</code> Node-local observations Auto-promotes if no conflict <code>contested/</code> Conflicting high-confidence evidence Requires explicit RESOLUTION <code>archived/</code> Superseded canonical beliefs Automatic on supersession"},{"location":"modules/reducer_v0/#event-types","title":"Event Types","text":""},{"location":"modules/reducer_v0/#observation","title":"OBSERVATION","text":"<p>Raw observation from a sensor, actor, or AI system.</p> <pre><code>event = {\n    \"type\": \"OBSERVATION\",\n    \"subject\": \"family_tree\",\n    \"predicate\": \"child_of\",\n    \"value\": \"John\",\n    \"confidence\": 0.95,\n    \"namespace\": \"local\",  # defaults to local\n}\n</code></pre> <p>\u2192 Lands in <code>local/</code>. If no conflict, auto-promotes to <code>canonical/</code> with next attestation.</p>"},{"location":"modules/reducer_v0/#attestation","title":"ATTESTATION","text":"<p>Institutional claim. Moves observation to <code>canonical/</code> or escalates conflict to <code>contested/</code>.</p> <pre><code>event = {\n    \"type\": \"ATTESTATION\",\n    \"subject\": \"family_tree\",\n    \"predicate\": \"child_of\",\n    \"value\": \"John\",\n    \"confidence\": 0.99,  # higher confidence\n}\n</code></pre>"},{"location":"modules/reducer_v0/#retraction","title":"RETRACTION","text":"<p>Removes or archives a belief. Original evidence preserved in <code>archived/</code>.</p>"},{"location":"modules/reducer_v0/#reducer_epoch","title":"REDUCER_EPOCH","text":"<p>Marks a version point. Allows checkpointing of state for fast replay.</p>"},{"location":"modules/reducer_v0/#core-functions","title":"Core Functions","text":""},{"location":"modules/reducer_v0/#sovereignreducerv0","title":"<code>SovereignReducerV0</code>","text":"<p>The main reducer class.</p> <pre><code>from provara.reducer_v0 import SovereignReducerV0\n\nreducer = SovereignReducerV0()\nstate = reducer.apply_events([event1, event2, event3])\n\n# state.canonical \u2192 confirmed beliefs\n# state.contested \u2192 conflicting high-confidence claims\n# state.state_hash \u2192 byte-identical hash of entire state\n</code></pre>"},{"location":"modules/reducer_v0/#apply_eventsevents-listdictstr-any-statesnapshot","title":"<code>apply_events(events: List[Dict[str, Any]]) -&gt; StateSnapshot</code>","text":"<p>Process a list of events and return final state.</p> <pre><code>events = [\n    {\"type\": \"OBSERVATION\", \"subject\": \"x\", \"predicate\": \"p\", \"value\": 1, \"confidence\": 0.5},\n    {\"type\": \"OBSERVATION\", \"subject\": \"x\", \"predicate\": \"p\", \"value\": 2, \"confidence\": 0.6},\n]\n\nstate = reducer.apply_events(events)\n\n# state.contested[\"x:p\"] \u2192 both values (conflicting)\n# state.state_hash \u2192 deterministic SHA-256 of entire state\n</code></pre>"},{"location":"modules/reducer_v0/#confidence-thresholds","title":"Confidence Thresholds","text":"<ul> <li>Local promotion: 0.5 default (configurable)</li> <li>Conflict threshold: 0.5 (two observations with &gt;= 0.5 confidence conflict)</li> <li>Agreement strength: Max confidence retained (if two observations agree on same value, confidence increases)</li> </ul>"},{"location":"modules/reducer_v0/#state-hash-guarantee","title":"State Hash Guarantee","text":"<p>Two key properties:</p> <ol> <li>Determinism: <code>state_hash(events) == state_hash(events)</code> always</li> <li>Content-addressability: State hash changes if any event changes, added, or removed</li> </ol> <p>This enables: - Auditing: \"Verify state hash matches my computation\" - Caching: \"State hash is my cache key\" - Checkpointing: \"Store state hash as signing anchor\"</p>"},{"location":"modules/reducer_v0/#error-handling","title":"Error Handling","text":"<p>Malformed events are logged but don't crash the reducer:</p> <pre><code>event_malformed = {\"type\": \"OBSERVATION\"}  # missing subject\n\nstate = reducer.apply_events([event_malformed])\n# Event skipped. state._ignored_types tracks what was skipped.\n</code></pre>"},{"location":"modules/reducer_v0/#performance","title":"Performance","text":"<p>For N events: - Time: O(N) single pass - Space: O(unique_beliefs) \u2014 one entry per (subject, predicate) pair - Typical: 1000 events \u2192 &lt; 10ms, &lt; 100KB state</p>"},{"location":"modules/reducer_v0/#example-family-tree-resolution","title":"Example: Family Tree Resolution","text":"<pre><code>from provara.reducer_v0 import SovereignReducerV0\n\nreducer = SovereignReducerV0()\n\n# Alice observes: Bob is John's child\nevent1 = {\n    \"type\": \"OBSERVATION\",\n    \"subject\": \"John\",\n    \"predicate\": \"child_of\",\n    \"value\": \"Bob\",\n    \"confidence\": 0.90,\n    \"actor\": \"alice\",\n    \"timestamp_utc\": \"2024-01-01T00:00:00Z\"\n}\n\n# Carol contradicts: Bob is Frank's child\nevent2 = {\n    \"type\": \"OBSERVATION\",\n    \"subject\": \"Frank\",\n    \"predicate\": \"child_of\", \n    \"value\": \"Bob\",\n    \"confidence\": 0.85,\n    \"actor\": \"carol\",\n    \"timestamp_utc\": \"2024-01-02T00:00:00Z\"\n}\n\nstate = reducer.apply_events([event1, event2])\n\n# state.contested[\"Bob:child_of\"] \u2192 [{value: \"John\", confidence: 0.90}, {value: \"Frank\", confidence: 0.85}]\n\n# Alice issues ATTESTATION to resolve\nresolution = {\n    \"type\": \"ATTESTATION\",\n    \"subject\": \"John\",\n    \"predicate\": \"child_of\",\n    \"value\": \"Bob\",\n    \"confidence\": 0.99,\n}\n\nstate2 = reducer.apply_events([event1, event2, resolution])\n# state2.canonical[\"John:child_of\"] \u2192 Bob (attested)\n# state2.contested cleared (or evidence preserved)\n</code></pre>"},{"location":"modules/reducer_v0/#references","title":"References","text":"<ul> <li>Provara Protocol: Reducer Specification</li> <li>Four-Namespace Model</li> </ul>"},{"location":"modules/rekey_backpack/","title":"rekey_backpack","text":"<p>Module: <code>src/provara/rekey_backpack.py</code></p> <p>Key rotation protocol. Implements two-event model: KEY_REVOCATION + KEY_PROMOTION.</p>"},{"location":"modules/rekey_backpack/#security-model","title":"Security Model","text":"<p>The compromised key cannot authorize its own replacement. Rotation must be signed by a surviving trusted authority (root or quorum key).</p>"},{"location":"modules/rekey_backpack/#core-functions","title":"Core Functions","text":""},{"location":"modules/rekey_backpack/#rekeyvault_path-path-old_key_id-str-new_private_key_b64-str-current_private_key_b64-str-none","title":"<code>rekey(vault_path: Path, old_key_id: str, new_private_key_b64: str, current_private_key_b64: str) -&gt; None</code>","text":"<p>Perform atomic key rotation.</p> <pre><code>from provara.rekey_backpack import rekey\nfrom pathlib import Path\n\nvault = Path(\"My_Backpack\")\n\n# Revoke compromised key (signed by trusted root key)\nrekey(\n    vault,\n    old_key_id=\"bp1_old123...\",\n    new_private_key_b64=\"...\",  # new key bytes\n    current_private_key_b64=\"...\",  # root key (authority)\n)\n\n# Creates two events:\n# 1. KEY_REVOCATION (old key marked untrusted)\n# 2. KEY_PROMOTION (new key marked trusted)\n</code></pre>"},{"location":"modules/rekey_backpack/#two-event-model","title":"Two-Event Model","text":""},{"location":"modules/rekey_backpack/#event-1-key_revocation","title":"EVENT 1: KEY_REVOCATION","text":"<pre><code>{\n    \"type\": \"KEY_REVOCATION\",\n    \"revoked_key_id\": \"bp1_old123...\",\n    \"reason\": \"Suspected compromise\",\n    \"timestamp_utc\": \"2024-02-17T16:00:00Z\",\n    \"signed_by\": \"bp1_root...\"\n}\n</code></pre>"},{"location":"modules/rekey_backpack/#event-2-key_promotion","title":"EVENT 2: KEY_PROMOTION","text":"<pre><code>{\n    \"type\": \"KEY_PROMOTION\",\n    \"new_key_id\": \"bp1_new456...\",\n    \"new_public_key\": \"base64-encoded-32-bytes\",\n    \"timestamp_utc\": \"2024-02-17T16:00:01Z\",\n    \"signed_by\": \"bp1_root...\"\n}\n</code></pre>"},{"location":"modules/rekey_backpack/#chain-verification-after-rekey","title":"Chain Verification After Rekey","text":"<p>The sync layer verifies:</p> <ol> <li>EVENT 1 is signed by surviving authority (not the compromised key)</li> <li>Compromised key is marked revoked in identity/keys.json</li> <li>EVENT 2 introduces new key and marks it active</li> <li>No events after revocation can be signed by revoked key</li> </ol>"},{"location":"modules/rekey_backpack/#example-disaster-recovery","title":"Example: Disaster Recovery","text":"<pre><code>from provara.rekey_backpack import rekey\nfrom provara.backpack_signing import generate_keypair\nimport base64\nfrom pathlib import Path\n\nvault = Path(\"My_Backpack\")\n\n# 1. Assume root key is compromised\n# 2. Use quorum key (recovery key) to revoke it\n\n# Generate new root key\nnew_private, new_public = generate_keypair()\nnew_private_b64 = base64.b64encode(new_private).decode()\n\n# Quorum key signs the rotation\nquorum_private_b64 = \"...\"  # from secure storage (was in different physical location)\n\n# Perform rotation\nrekey(\n    vault,\n    old_key_id=\"bp1_root_old...\",\n    new_private_key_b64=new_private_b64,\n    current_private_key_b64=quorum_private_b64,\n)\n\n# Result:\n# - Old root key revoked\n# - New root key active\n# - All future events signed by quorum key until rotation completes\n# - Vault chain remains unbroken\n</code></pre>"},{"location":"modules/rekey_backpack/#important-notes","title":"Important Notes","text":"<ol> <li>Atomicity \u2014 Both events are added in one transaction</li> <li>Revocation permanent \u2014 Revoked key can never be reactivated</li> <li>Chain continuity \u2014 No events are deleted or rewritten</li> <li>Auditability \u2014 Full rotation history is preserved in event log</li> </ol>"},{"location":"modules/rekey_backpack/#references","title":"References","text":"<ul> <li>Provara: Key Rotation Specification</li> <li>Key Management Guide</li> </ul>"},{"location":"modules/sync_v0/","title":"sync_v0","text":"<p>Module: <code>src/provara/sync_v0.py</code></p> <p>Union merge with causal chain verification, fork detection, and fencing tokens. Enables safe multi-device vault synchronization.</p>"},{"location":"modules/sync_v0/#golden-rule","title":"Golden Rule","text":"<p>Truth is not merged. Evidence is merged. Truth is recomputed.</p> <p>When two vaults diverge, <code>sync_v0</code> merges their raw events (union merge), then replays the reducer to derive fresh beliefs. No heuristics, no last-write-wins.</p>"},{"location":"modules/sync_v0/#core-functions","title":"Core Functions","text":""},{"location":"modules/sync_v0/#syncvault_a-path-vault_b-path-output_path-path-dictstr-any","title":"<code>sync(vault_a: Path, vault_b: Path, output_path: Path) -&gt; Dict[str, Any]</code>","text":"<p>Merge two vaults. Returns merged vault + summary of new events.</p> <pre><code>from provara.sync_v0 import sync\nfrom pathlib import Path\n\nvault1 = Path(\"My_Backpack_Desktop\")\nvault2 = Path(\"My_Backpack_Phone\")\nmerged = Path(\"My_Backpack_Merged\")\n\nresult = sync(vault1, vault2, merged)\n\n# result = {\n#     \"events_from_a\": 42,\n#     \"events_from_b\": 38,\n#     \"duplicates_removed\": 5,\n#     \"new_events_in_merge\": 75,\n#     \"state_hash\": \"abc123...\",\n#     \"conflicts\": [],  # or list of conflicting beliefs\n# }\n</code></pre>"},{"location":"modules/sync_v0/#verify_chainevents-listdictstr-any-public_keys-dictstr-str-bool","title":"<code>verify_chain(events: List[Dict[str, Any]], public_keys: Dict[str, str]) -&gt; bool</code>","text":"<p>Verify causal chain + signatures. Returns True if all events are valid.</p> <pre><code>from provara.sync_v0 import verify_chain\n\nis_valid = verify_chain(events, public_keys_dict)\n\nif not is_valid:\n    raise ValueError(\"Chain verification failed!\")\n</code></pre>"},{"location":"modules/sync_v0/#detect_forksvault_path-path-listtuplestr-listdictstr-any","title":"<code>detect_forks(vault_path: Path) -&gt; List[Tuple[str, List[Dict[str, Any]]]]</code>","text":"<p>Detect fork branches in a vault (same actor, diverging causal chains).</p> <pre><code>from provara.sync_v0 import detect_forks\n\nforks = detect_forks(vault_path)\n\nif forks:\n    for actor, diverged_events in forks:\n        print(f\"Fork detected for {actor}: {len(diverged_events)} events\")\n</code></pre>"},{"location":"modules/sync_v0/#merge-algorithm","title":"Merge Algorithm","text":"<ol> <li>Union merge \u2014 Collect all events from both vaults</li> <li>Deduplication \u2014 Remove duplicates by event_id</li> <li>Chain validation \u2014 Verify each actor's causal chain</li> <li>Fork detection \u2014 Flag branches (same actor, diverging chains)</li> <li>Reducer replay \u2014 Re-run reducer on merged events</li> <li>State hash \u2014 Compute final state_hash</li> </ol> <p>Result: Two vaults \u2192 One merged vault with all evidence, no conflicts at belief layer.</p>"},{"location":"modules/sync_v0/#causal-chain-invariants","title":"Causal Chain Invariants","text":"<p>For each actor:</p> <ol> <li>First event has <code>prev_event_hash = null</code></li> <li>Subsequent events have <code>prev_event_hash = event_id</code> of previous event (same actor)</li> <li>No gaps \u2014 If event E2 claims E1 as prev, E1 must exist</li> <li>No cross-actor references \u2014 Actor A events cannot reference actor B events</li> </ol> <p>Violation \u2192 chain verification fails.</p>"},{"location":"modules/sync_v0/#fencing-tokens","title":"Fencing Tokens","text":"<p>Optional security mechanism (future extension). Prevents stale updates from old vault snapshots.</p> <pre><code>Vault snapshot at time T has token=V1\nAt time T+1, new token V2 is issued\nOlder events with V1 are rejected on sync\n</code></pre>"},{"location":"modules/sync_v0/#example-multi-device-sync","title":"Example: Multi-Device Sync","text":"<pre><code>from provara.sync_v0 import sync, verify_chain\nfrom provara.backpack_integrity import compute_merkle_root\nfrom pathlib import Path\nimport json\n\n# 1. Start with vault on desktop\ndesktop_vault = Path(\"Desktop_Vault\")\n\n# 2. Copy to phone, make changes\nphone_vault = Path(\"Phone_Vault\")\n\n# Alice adds family event on desktop\n# Bob adds separate family event on phone\n\n# 3. Sync back to desktop\nmerged = Path(\"Desktop_Vault_Merged\")\nresult = sync(desktop_vault, phone_vault, merged)\n\nprint(f\"Merged {result['events_from_a']} + {result['events_from_b']} events\")\nprint(f\"New beliefs state_hash: {result['state_hash']}\")\n\n# 4. Verify merged vault\nmanifest = json.loads((merged / \"manifest.json\").read_text())\nfiles = [merged / f for f in manifest[\"files\"]]\nmerkle_root = compute_merkle_root(files)\n\nif merkle_root == manifest[\"merkle_root\"]:\n    print(\"\u2713 Merged vault integrity verified\")\n\n    # 5. Copy merged back to phone\n    # (full bi-directional sync)\nelse:\n    print(\"\u2717 Tampering detected!\")\n</code></pre>"},{"location":"modules/sync_v0/#conflict-resolution","title":"Conflict Resolution","text":"<p>If Alice and Bob write conflicting observations on the same belief:</p> <ol> <li>Both observations land in <code>contested/</code> namespace</li> <li>Whoever issues the next ATTESTATION wins (or both remain contested)</li> <li>No data loss \u2014 full history preserved in <code>archived/</code> and <code>contested/</code></li> </ol>"},{"location":"modules/sync_v0/#performance","title":"Performance","text":"<ul> <li>Merge: O(N) where N = total events</li> <li>Typical: 1000 events per vault \u2192 ~5ms merge</li> <li>Verification: 0.5ms per event</li> </ul>"},{"location":"modules/sync_v0/#references","title":"References","text":"<ul> <li>Provara: Sync Specification</li> <li>Multi-Device Vault Sync Guide</li> </ul>"}]}